# 이싸피는 싸피 식당에 당근을 공급하고 있다. 이싸피의 당근은 맛도 있지만, 영양분이 풍부해 당근을 먹은 사람들이 알고리즘 문제를 더 잘 풀게 된다고 한다. 하지만 이싸피도 싸피 식당의 복잡한 포장 조건 때문에 늘 고생하고 있다.
# 싸피식당의 요구 조건은 다음과 같다.
# N개의 당근을 주문하면 대, 중, 소 상자로 구분해 포장해야 한다.
# 같은 크기의 당근은 같은 상자에 들어있어야 한다.
# 비어 있는 상자가 있으면 안 된다.
# 한 상자에 N/2개(N이 홀수면 소수점 버림)를 초과하는 당근이 있어서도 안 된다.
# 앞의 조건을 만족하면서도, 각 상자에 든 당근의 개수 차이가 최소가 되도록 포장해야 한다. 그리고 이때의 개수 차이를 서류에 표시 한다.
# 새로운 주문이 들어와 이싸피는 N개의 당근을 밭에서 뽑아왔다. 대, 중, 소 상자를 각각 저울에 올려 포장해보는 대신, 뽑은 당근의 크기를 입력하면 모든 조건을 확인하는 프로그램을 만들어 이싸피가 쉽게 당근을 포장할 수 있게 도와보자.
# 예시1)
# 뽑아온 당근이 3개이고, 크기가 1 2 3이라면 다음과 같이 포장할 수 있다.
# 소 [ 1 ], 중 [ 2 ], 대 [ 3 ], 상자에 든 당근의 개수 차이는 0
# 예시2)
# 당근이 5개이고 크기가 1 1 1 2 3 이라면, 조건 (1)~(3)을 만족하는 포장은 다음과 같다.
# 소[ 1 1 1 ], 중 [ 2 ], 대 [ 3 ], 당근의 개수 차이는 2
# 하지만 이 경우 5/2개(2개)를 초과하는 상자가 있으므로 조건(4)를 만족하지 못한다.

# 예시3)
# 당근이 8개 이고, 크기가 1 2 3 4 5 6 7 8인 경우이다. 우선 다음과 같이 포장할 수도 있다.
# 소[ 1 2 3 4 ], 중[ 5 ], 대[ 6 7 8 ], 당근의 개수 차이는 3
# 하지만 다음과 같이 포장해야 조건(5)를 만족한다.
# 소[ 1 2 3 ], 중[ 4 5 6 ], 대[ 7 8 ], 당근의 개수 차이는 1
# 또는 다음과 같은 경우도 조건(5)를 만족한다.
# 소[ 1 2 ], 중[ 3 4 5 ], 대[ 6 7 8 ], 당근의 개수 차이는 1

#입력
# 첫 줄에 총 수확 횟수 T가 주어진다.
# 각 수확에 대해, 첫 줄에 당근의 개수N, 다음 줄에 수확한 N개의 당근 크기 Ci가 빈칸으로 구분되어 주어진다. ( 3<=N<=1000, 1<=Ci<=30 )

#출력
# 과 1번부터인 수확번호에 이어, 포장 할 수 없는 경우 -1, 포장할 수 있으면 상자에 들어있는 당근의 개수 차이가 최소일 때의 차이값을 출력하라.

T = int(input())
for tc in range(1,T+1):
    n = int(input())
    Ci = list(map(int,input().split()))

    ans = 10 ** 100
    Ci.sort()
    
    if n % 2 != 0:
        k = (n-1)/2
    else:
        k = n/2


    for i in range(n-2):
        for j in range(i+1,n-1):
            sm = Ci[:i+1]
            md = Ci[i+1:j+1]
            b = Ci[j+1:]

            c1 = len(sm)
            c2 = len(md)
            c3 = len(b)

            if c1 <= k and c2 <= k and c3 <= k:
                max_c = max(c1, c2, c3)
                min_c = min(c1, c2, c3)

                if ans > max_c - min_c:
                    ans = max_c - min_c

    TLqkf
    if ans == 10 ** 100:
        ans = -1      
    print(f'#{tc} {ans}')