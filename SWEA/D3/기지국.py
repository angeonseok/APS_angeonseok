"""
SS 텔레콤에서 현재 기지국의 위치와 집들이 표시된 지도를 2차원 n x n 배열로 변환하여,기지국에 커버 되지 않는 집의 수를 찾고자 한다.
기지국은 [그림1]과 같이 세가지 종류가 있다. 각각의 기지국은 기지국이 위치한 셀에서 동서남북으로 각 1개, 2개, 3개의 셀을 커버하며, 하나의 집은 1개의 셀에 있다.
[그림2]에서 4개의 기지국(동서남북으로 1칸씩 커버)으로 커버가 되지 않는 집의 수는 4개이다.
(그림은 없다)
주어진 2차원 배열 지도에 위치한 기지국으로 커버되지 않는 집의 수를 찾는 프로그램을 작성하시오.

#제약사항
2차원 배열의 크기의 n은 50이하이다. 기지국의 수는 50이하이다.

#입력
첫 줄에는 테스트 케이스의 수가 주어지고, 그 다음 줄부터 각 테스트 케이스가 n개의 줄로 구성된다. 테스트 케이스의 첫 줄에는 n이 주어지고, 다음 n개 줄에는 2차원 배열의 각 행이 한 줄에 차례로 주어진다. 단, 집이 위치한 원소는 'H', 기지국이 위치한 원소는 'A', 'B', 'C'로 표시하며, 각각 동서남북으로 1, 2, 3개를 커버하는 기지국이다. 'X'인 원소는 아무 것도 없다는 것을 나타낸다.

#출력
각 줄은 '#x'로 시작하고 공백을 하나 둔 다음, 테스트 케이스에 주어진 기지국에 cover가 되지 않는 집의 수를 출력한다. 단, x는 테스트 케이스 번호이다.
"""

T = int(input())
for tc in range(1,T+1):
    n = int(input())
    mat = [list(input().strip()) for _ in range(n)]
    
    #딕셔너리로 범위 저장
    ss = {'A' : 1, 'B' : 2, 'C' : 3}

    for i in range(n):
        for j in range(n):

            #기지국이면
            if mat[i][j] in ss:
                r = ss[mat[i][j]]   #범위 정보 저장
                mat[i][j] = 'X'     #밀어버리기

                #기지국 기준 범위만큼 밀어버리기
                for dir in ((0,1), (1,0), (0,-1), (-1,0)):
                    for k in range(1, r + 1):
                        ni, nj = i + dir[0] * k, j + dir[1] * k

                        if 0 <= ni < n and 0 <= nj < n:
                            if mat[ni][nj] =='H':
                                mat[ni][nj] = 'X'
    
    #카운팅하면 끝
    ans = sum(row.count('H') for row in mat)
    print(f'#{tc} {ans}')